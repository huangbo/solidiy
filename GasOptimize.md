// Gas Optimize
/*
. 状态变量中只应该保存Solidity智能合约需要使用的数据，而其他数据都应该利用智能合约的事件机制转储到外部.事件是以太坊中gas成本最低的操作之一，一次触发大约消耗4000 gas。
. 避免使用ERC721Enumerable，并用Counter代替totalSupply()来追踪代币ID，买家可以节省高达70%的铸币手续费和高达35%的转账费。
. 使用constant immutable 
. 合理使用calldata memory storage 存储位置
. 在 Solidity 语言中
  Solidity 编译器在编译合约时，将严格的根据定义顺序，依次给他们设定存储位置。所以变量的定义顺序会影响存储空间进而影响gas的使用
  合理定义数据类型，尽量少占用空间
. 白名单使用映射而不是数组遍历，但是如果白名单过多也会导致映射需要的空间过大，优化为Merkle树方案，合约只保存Merkle树跟用来验证是否白名单，Merkle树在后端保存处理
. NFT token第一个从1开始，变量从0设置为非0代价比较昂贵
. 减少代码量：修改器、库合约等实现公共逻辑
. 运行次数 (--optimize-runs )指定部署代码的每个操作码将在合同的整个生命周期中执行的大致频率。
  这意味着它是代码大小(部署成本)和代码执行成本(部署后成本)之间的权衡参数。“run”参数“1”将生成简短但昂贵的代码。相反，较大的“run”参数将生成更长但更省油的代码。
*/



// Solidity 合约数据存储布局
/*
Storage 是一个巨大的Map，一共2^256个插槽 (slot)，每个插糟有 32字节，合约中的“状态变量”会根据其具体类型分别保存到这些插槽中。
contract StorageExample2 {
    uint256 a = 11; // 插槽 0
    uint8 b = 12; // 插槽1，1 字节
    uint128 c = 13; // 插槽1，16 字节
    bool d = true; // 插槽1，1 字节
    uint128 e =  14;//插槽2
}

. 字段 a 需要 32 字节占用 1 个插槽，存于插槽 0 中。
. b 只需要 1 字节，存于插槽 1 中。
. 因为 插槽 1 还剩余 31 字节可用，而 c 只需要 16 字节，因此 c 也可以存储在插槽 1 中。
. 此时，插槽 1 剩余 15 字节，可以继续存放 d 的一字节。
. 插槽 1 还剩余 14 字节，但是 e 需要 16 字节存储，插槽 1 已不能容纳 e。需将 e 存放到下一个插槽 2 中。

读取插槽1中的数据得到：
solt1 = "0x0000000000000000000000000000010000000000000000000000000000000d0c"
solt_len = len(solt1)
data = web3.eth.getStorageAt(contractAddr,1);
b = parseInt(data.substr(solt_len-1*2,1*2),16);
c = parseInt(data.substr(solt_len-1*2-16*2,16*2),16);
d = parseInt(data.substr(solt_len-1*2-16*2-1*2,1*2),16);

但这种机制也引发了另一个问题。因为以太坊虚拟机每次读取数据都是 32 字节，当你的数据小于 32 字节时需要更多的指令操作才能将所需值取出。 
还需要截取 32 字节的中间一小部分。 在使得相比取 32 字节值的数据，需要花费更多的 gas 来获取小于 32 字节的数据。 当然这种开销，相对于更多的存储占用要便宜得多。

*/

// solidity 因为共识需要在多个节点上进行运算校验，即在每个节点上运行都能获得确定性结果，不能因为硬件或者本地环境而产生偏差。
  所以生成某个数据不能使用类似当前时间戳，不确定变量进行参与生成。可以使用区块难度、区块打包时间等确定的变量